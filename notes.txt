struct sockaddr_in addr;

addr.sin_port
addr.sin_addr.s_addr

when you get the "Request" and "ServerCnf[]" and "addr":
    check "addr" against "ServerCnf[i]".host:port;
    if you get a match: "matches".push(i)
    check "ServerCnf[i+1]"

	if "matches".size() > 1 :
		check "Request".header["Host"] against "ServerCnf".server_names[i]
		if you get a match : use "ServerCnf".server_names[i]
		else check "ServerCnf".server_names[i+1]
		if no matches are found : user Default

----------------------------------------------------------------------

req.path must start with '/'; if not => 400 Bad Request
consecutive '/' can be skipped (at any position of the path)
if req.path is a directory and not Terminated with a '/' => 301 Moved Permanently

duplicate locations are not allowed

locs / /dir0/ /dir0/dir00/

path /dir0/dir00/


if !srv.index and !index.html:
	if autoindex = true: list files
	else return 403 Frobidden


get info about a file: stat(char* path, struct stat *):
	S_IFTM (type of file)
	S_IFDIR (directory)
	S_IDREG (regular file)
	eg: stat(path, st);
		(st.s_mode & S_IFTM) == S_IFDIR => path is dir
		(st.s_mode & S_IFTM) == S_IFREG => path is file
	stat() == -1:	errno == EACCESS (Permission denied for one of the path components) => 403 Forbidden
					errno == ENOENT (file not found) => 404 Not Found
					errno == ENOTDIR (path component is not dir) => 404 Not Found

error_page [300, 599]

redirection:
	300, 305 => body = redir.location; no Location header
	304 => no body; no Location header
	301, 302, 303, 307, 308 => set Location header, costum body

---------------------------------------------------------------------
POST request:
	Content-Type: x-www-form-urlencoded (key1=value1&key2=value2..)
	Content-Type: multipart/form-data; boundary=boundary
	(
		--boundary
		Content-Disposition: form-data; name="key1"

		value1
		--boundary
		Content-Disposition: form-data; name="key2"

		value2
		--boundary--
	)

cgi env:
	QUERY_STRING=req.query;
	SCRIPT_FILENAME=fpath;
	PATH_INFO=cgi_script;
	CONTENT_TYPE=;
	CONTENT_LENGTH=;
	REQUEST_METHOD=;


GET CGI ENV
{
	HTTP_ACCEPT = '*/*',
	HTTP_USER_AGENT = 'curl/7.68.0',
	HTTP_HOST = '127.0.0.1:8080',

	REDIRECT_STATUS = '200',
	SERVER_NAME = 'localhost',
	SERVER_PORT = '8080',
	SERVER_ADDR = '127.0.0.1',
	REMOTE_PORT = '52480',
	REMOTE_ADDR = '127.0.0.1',
	SERVER_SOFTWARE = 'nginx/1.20.2',
	GATEWAY_INTERFACE = 'CGI/1.1',
	REQUEST_SCHEME = 'http',
	SERVER_PROTOCOL = 'HTTP/1.1',
	DOCUMENT_ROOT = '/mnt/c/Users/Lenovo/Desktop/webserv/www',
	DOCUMENT_URI = '/hello.php',
	REQUEST_URI = '/hello.php?name=hamza&password=pass!!word',
	SCRIPT_NAME = '/hello.php',
	CONTENT_LENGTH = '',
	CONTENT_TYPE = '',
	REQUEST_METHOD = 'GET',
	QUERY_STRING = 'name=hamza&password=pass!!word',
	SCRIPT_FILENAME = '/mnt/c/Users/Lenovo/Desktop/webserv/www/hello.php',
	FCGI_ROLE = 'RESPONDER',
}

POST CGI ENV
{
	HTTP_CONTENT_TYPE = 'application/x-www-form-urlencoded',
	HTTP_CONTENT_LENGTH = '30',
	HTTP_ACCEPT = '*/*',
	HTTP_USER_AGENT = 'curl/7.68.0',
	HTTP_HOST = '127.0.0.1:8080',

	REDIRECT_STATUS = '200',
	SERVER_NAME = 'localhost',
	SERVER_PORT = '8080',
	SERVER_ADDR = '127.0.0.1',
	REMOTE_PORT = '52488',
	REMOTE_ADDR = '127.0.0.1',
	SERVER_SOFTWARE = 'nginx/1.20.2',
	GATEWAY_INTERFACE = 'CGI/1.1',
	REQUEST_SCHEME = 'http',
	SERVER_PROTOCOL = 'HTTP/1.1',
	DOCUMENT_ROOT = '/mnt/c/Users/Lenovo/Desktop/webserv/www',
	DOCUMENT_URI = '/hello.php',
	REQUEST_URI = '/hello.php',
	SCRIPT_NAME = '/hello.php',
	CONTENT_LENGTH = '30',
	CONTENT_TYPE = 'application/x-www-form-urlencoded',
	REQUEST_METHOD = 'POST',
	QUERY_STRING = '',
	SCRIPT_FILENAME = '/mnt/c/Users/Lenovo/Desktop/webserv/www/hello.php',
	FCGI_ROLE = 'RESPONDER',
}

---------------------------------------------------------------------------------
req.method != allowed_methods ==> 403
POST static_file ==> 405
POST directory:
	if (upload) => _upload;
	if (index is CGI) => CGI
	if (index is static) => 405
